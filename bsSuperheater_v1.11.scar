program bsSuperHeater;
{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                O.S.I. Official SCAR Include - bsSuperHeater               v1.11
--------------------------------------------------------------------------------
SCRIPT INFO
--------------------------------------------------------------------------------
Script Name:      bsSuperHeater
Script Author(s): Bixby Sayz
Script Version:   1.11
Script Date:      2012-01-26. RS2 Build 699.
Description:      Smelts ores using superheat spell (regular spellbook).

                  More scripts can be found at http://forums.scar-divi.com

--------------------------------------------------------------------------------
FEATURES
--------------------------------------------------------------------------------
- Smelts ores using superheat spell (regular spellbook).
- Sorts spellbook and uses optimized clicking to minimize mouse mousement.
- Stats report includes magic/smithing/total experience and experience per hour.
- Fully multiplayer.
- Supports all ores/bars including blurite (just because I can).
- Supports any bank supported by OSI.
- Fast! And rock solid. The only thing that will kill this randoms.
- Now with soul wars bank chest support! (use Loc_SW as bank location)

--------------------------------------------------------------------------------
     IMPORTANT - IMPORTANT - IMPORTANT - IMPORTANT - IMPORTANT - IMPORTANT
--------------------------------------------------------------------------------
USE THIS SCRIPT RESPONSIBLY
- Do not run this script for 3 days straight on a single player. Duh!
- BE PATIENT when buying/selling supplies!!!
- Buy your supplies AT OR BELOW mid price.
- Sell your finished product AT OR ABOVE mid price.
- Failure to do so will screw up the market for all of us. Don't be an idiot.

--------------------------------------------------------------------------------
REQUIREMENTS
--------------------------------------------------------------------------------
- SCAR 3.30 or higher.
- Latest OSI includes.
- Optional SMART.

--------------------------------------------------------------------------------
SKILL/QUEST/ITEM REQUIREMENTS
--------------------------------------------------------------------------------
- Level 43 Magic.
- Nature runes in 1st inventory slot.
- Fire staff equipped in weapon slot.
- Ores visible in bank.

--------------------------------------------------------------------------------
INSTRUCTIONS
--------------------------------------------------------------------------------
- Start in any bank supported by OSI.
- Place your nature runes in 1st inventory slot.
- Equip/weild your fire staff.
- Ores must be visible in bank. Closer to the right side of the bank will
  speed banking and increase your experience per hour (very) slightly.
- Comment/uncomment appropriate defines. (line 182).
- Fill in account info in DeclarePlayers (line 240).

--------------------------------------------------------------------------------
KNOWN ISSUES
--------------------------------------------------------------------------------
- Randoms can and will stop this script. If running multiplayer then script will
  continue on with next player.
- Sometimes hops to a different bank booth everytime it banks. (Talk about
  screaming "I am a bot!") Blame OSI's banking routines.
- On rare occasions random finding will falsely detect an unknown random
  immediately after banking. Fixed???
- Sometimes fails to read experience from stats tab. Fixed???

--------------------------------------------------------------------------------
VERSION HISTORY
--------------------------------------------------------------------------------
2012-01-26 - v1.11
- Added soul wars bank chest support.
- Fixed script continuing even if player setup failed.
- Get experience hopefully fixed. Failsafe added to fall back to calculations
  just in case.
- Fixed issue with popup interfering with withdraw.
- Added world switching.

2012-01-13 - v1.10 - First Public Release
- Fixed osi update breaking time worked.
- Added workaround for "runescape has been reloaded".
- Tweaked reports layout/when to report.
- Changed spellbook sorting to support both non-member/members.
- Moved superheat spell location into player record.
- Added experience chart to comments.
- Fixed reporting incorrect time worked.
- Fixed incorrect click pattern when low on ores.
- Fixed sometimes failing to sort spellbook.
- Fixed minor spacing issue in report.
- Fixed mouseover text sometimes causing find spell icon to fail.
- Fixed banking reporting success even when failed.
- Fixed (i hope) lag sometimes causing accidental switch to objectives tab.
- Increased the timeouts to make it more lag friendly.

2012-01-09 - v1.00 - Private Release
- Supports all ores/bars.
- Optimized clicking.
- Stats.
- Multiplayer.

2012-12-12 - v0.01 - Beta/Development Version

--------------------------------------------------------------------------------
FUTURE REVISIONS
--------------------------------------------------------------------------------
- Reworking of internals to make it more faster & more memory efficient.
- Player form.
- Manual random solving.
- Coalbags. (unlikely unless someone wants to loan an account)
- Urns (need to get my crafting up first).

--------------------------------------------------------------------------------
CREDITS
--------------------------------------------------------------------------------
- Freddy for bringing us SCAR. You're my hero!
- OSI Devs for the includes that make it possible.
- Bixby Sayz (oh wait, that's me!) for being insanely awesome.

--------------------------------------------------------------------------------
EXPERIENCE - Sample experience rates. YMMV.
--------------------------------------------------------------------------------

+----------+----------+----------+----------+
| Bar Type | M Exp/Hr | S Exp/Hr | T Exp/Hr |
+----------+----------+----------+----------+
| bronze   |   78,537 |    9,187 |   87,725 |
| iron     |  109,704*|   25,870 |  135,574*|
| steel    |   76,647 |   25,306 |  101,952 |
| mithril  |   53,683 |   30,387 |   84,070 |
| adamant  |   37,293 |   26,386 |   63,679 |
| rune     |   37,367 |   35,252 |   72,620 |
| silver   |   52,538 |   13,579 |   66,117 |
| gold     |   94,963 |   40,315*|  135,278 |
| blurite  |   85,448 |   12,898 |   98,346 |
+----------+----------+----------+----------+

* = Highest experience in category.

If you only care about experience rates and have more gp than you know what to
do with, superheat gold while wearing goldsmith gauntlets (double smithing xp).

Anything less than steel you will lose money. Steel is far and away the best
money maker. Rune is arguably the best smithing experience while showing a
modest profit.

You want:
     PROFIT: Steel
  MAGIC EXP: Iron (or Gold)
  SMITH EXP: Gold (or Rune)

Note: These rates were generated on a member server before I realized the
      spellbook layout was less than optimal on members. Actual rates may be
      a bit higher then listed.

      This chart WILL NOT BE UPDATED. It is a guide only.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

/////////////////////////////////////////////
//////////////      DEFINES    //////////////
/////////////////////////////////////////////
{$DEFINE RS2}
{$DEFINE OSI_COLOR_ANTI_RANDOMS}
{$DEFINE SMART}                   // Comment out to disable SMART
//{$DEFINE DEBUG}                   // Comment out to disable debugging

/////////////////////////////////////////////
/////////////      INCLUDES     /////////////
/////////////////////////////////////////////
{$I OSI\OSI.scar}
{$I OSI\RS2\Skill\Smithing.scar}

/////////////////////////////////////////////
/////////////      CONSTANTS    /////////////
/////////////////////////////////////////////
const
  SCRIPT_NAME = 'bsSuperHeater';
  SCRIPT_VERSION = '1.11';
  SCRIPT_DATE = '2012-01-26';
  SCRIPT_AUTHOR = 'Bixby Sayz';

  // Constants for bank locations.
  Loc_SW = (Loc_GEB + 1);

  // Constants for referencing players array.
  SBAR = 0;    // Strings[0] = Which bar to make.
  IBNK = 0;    // Integers[0] = Which bank.
  IPRI = 1;    // Integers[1] = Dtm - primary ore.
  ISEC = 2;    // Integers[2] = Dtm - secondary ore.
  IBAR = 3;    // Integers[3] = Dtm - bar.
  IBPT = 4;    // Integers[4] = Bars per trip.
  BSEC = 0;    // Booleans[0] = Use secondary ore.
  ESXP = 0;    // Extendeds[0] = Smithing experience per bar.
  TICLK = 0;   // TIA[0] = Click pattern.
  TIOTH = 1;   // TIA[2] = Other details.
  TISTAT = 2;  // TIA[1] = Player stats.
  ISHX = 0;    // TIA[1][0] = Superheat spell icon location (x).
  ISHY = 1;    // TIA[1][1] = Superheat spell icon location (y).
  IBM = 0;     // TIA[2][0] = Bars made.
  ISME = 1;    // TIA[2][1] = Starting magic experience.
  ICME = 2;    // TIA[2][2] = Current magic experience.
  IMXP = 3;    // TIA[2][3] = Magic experience gained.
  IMPH = 4;    // TIA[2][4] = Magic experience per hour.
  ISML = 5;    // TIA[2][5] = Starting magic level.
  IMLV = 6;    // TIA[2][6] = Magic levels gained.
  ISSE = 7;    // TIA[2][7] = Starting smithing experience.
  ICSE = 8;    // TIA[2][8] = Current smithing experience.
  ISXP = 9;    // TIA[2][9] = Smithing experience gained.
  ISPH = 10;   // TIA[2][10] = Smithing experience per hour.
  ISSL = 11;   // TIA[2][11] = Starting smithing level.
  ISLV = 12;   // TIA[2][12] = Smithing levels gained.
  ITXP = 13;   // TIA[2][13] = Total experience gained.
  ITPH = 14;   // TIA[2][14] = Total experience per hour.

/////////////////////////////////////////////
///////////      CUSTOM TYPES     ///////////
/////////////////////////////////////////////

/////////////////////////////////////////////
/////////      GLOBAL VARIABLES     /////////
/////////////////////////////////////////////
var
  TimeToRun: Integer;        // Total time to run script.
  TimeBeforeBreak: Integer;  // Time to run each player before breaking.
  BreakTime: Integer;        // How long to break between players.

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure DeclarePlayers;
Contributors: Bixby Sayz
Description: Setup your player(s) in here.
Date Created: 2011-12-29. By Bixby Sayz. RS2 Build 695.
Last Modification: 2012-01-25. By Bixby Sayz. RS2 Build 699.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
procedure DeclarePlayers;
var
  NumPlayers: Integer;  // Number of players.
  I: Integer;           // Loop counter.
begin
  NumPlayers := 1;        // Change this to your number of players.
  CurrentPlayer := 0;     // Starting player. (0=1st, 1=2nd, 2=3rd, etc)
  TimeToRun := 480;       // Total time to run script (in minutes). (0 = run forever)
  TimeBeforeBreak := 45;  // Time before taking a break (in minutes). (0 = no breaks)
  BreakTime := 15;        // How long to break between players (in minutes). (0 = no break)
                          // Times will be randomized +/- 10 percent.

  // DON'T TOUCH THIS PART!!!
  SetLength(Players, NumPlayers);
  for I := 0 to (NumPlayers - 1) do
  with Players[I] do
  begin
    Status := 'Unknown';
    SetLength(Strings, 1);
    SetLength(Integers, 5);
    SetLength(Booleans, 1);
    SetLength(Extendeds, 1);
    SetLength(TIA, 3);
    SetLength(TIA[TIOTH], 2);
    SetLength(TIA[TISTAT], 15);
    TIA[TIOTH][ISHX] := 0;
    TIA[TIOTH][ISHY] := 0;
  end;

  // Setup player 0 (first player).
  with Players[0] do
  begin
    Name := 'Zezima';                  // In-game character name.
    Login := 'Zezima'                  // Login handle.
    Pass := 'You Wish';                // Login password.
    Pin := '';                         // Bank Pin. ('' for none)
    LampSkill := 'smithing';           // Skill for lamp/exp randoms.
    Member := False;                   // Members?
    BoxRewards := ['mote', 'ostume', 'lamp', 'nowledge', 'oins'];  // Partial text for rewards, place in desired order.
    Active := True;

    // bronze, iron, steel, mith, mithril, addy, adamant, rune, silver, gold, blurite (members)
    Strings[0] := 'steel';             // Bar to make.
    // loc_lbc, loc_akb, loc_feb, loc_fwb, loc_dyb, loc_veb, loc_vwb, loc_evb, loc_geb, loc_sw
    Integers[0] := Loc_VWB;            // Bank to use.
  end;

{ Uncomment and add more players here
  with Players[1] do
  begin
    Name := '';                        // In-game character name.
    Login := ''                        // Login handle.
    Pass := '';                        // Login password.
    Pin := '';                         // Bank Pin. ('' for none)
    LampSkill := 'smithing';           // Skill for lamp/exp randoms.
    Member := False;                   // Members?
    BoxRewards := ['mote', 'ostume', 'lamp', 'nowledge', 'oins'];  // Partial text for rewards, place in desired order.
    Active := True;

    Strings[0] := 'steel';             // Bar to make.
    Integers[0] := Loc_VWB;            // Bank to use.
  end;
}
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure WriteString(FuncName, S: String);
Contributors: Bixby Sayz
Description: Writes string to debug window prepended by time running.
Date Created: 2011-12-12. By Bixby Sayz. RS2 Build 689.
Last Modification: 2012-01-05. By Bixby Sayz. RS2 Build 696.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
procedure WriteString(FuncName, S: String);
var
  TR: Integer;  // Total time running.
  Hr: Integer;  // Hours.
  Mn: Integer;  // Minutes.
  Sc: Integer;  // Seconds.
  Ms: Integer;  // Milliseconds.
begin
  TR := GetTimeRunning;
  ConvertTime(TR, Hr, Mn, Sc);
  Ms := TR - (Hr * 3600000) - (Mn * 60000) - (Sc * 1000);
  WriteLn(Format('%.2d:%.2d:%.2d.%.3d [%s] %s', [Hr, Mn, Sc, Ms, FuncName, S]));
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function GroupDigits(Number: Integer): String;
Contributors: Bixby Sayz
Description: Format integer number with thousands separator.
Date Created: 2012-01-04. By Bixby Sayz. RS2 Build 696.
Last Modification: 2012-01-04. By Bixby Sayz. RS2 Build 696.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
function GroupDigits(Number: Integer): String;
begin
  Result := Format('%0.0n', [Number * 1.0]);
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function MyLogin: Boolean;
Contributors: Bixby Sayz
Description: Logs player in.
Date Created: 2012-01-06. By Bixby Sayz. RS2 Build 696.
Last Modification: 2012-01-13. By Bixby Sayz. RS2 Build 698.
Note: This is a workaround for login function conflicting with login property of
      players array.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
function MyLogin: Boolean;
begin
{$IFDEF DEBUG}
  WriteString('MyLogin', '');
{$ENDIF}

  // Atempt login.
  Result := Login;

  // If login failed and "runescape has been reloaded" error then restart smart
  // client.
  if not Result then
  begin
    WriteString('MyLogin', 'Failed login attempt.');
{$IFDEF SMART}
    if (Players[CurrentPlayer].Loc = 'RS updated') then
    begin
      Players[CurrentPlayer].Active := True;
      WriteString('MyLogin', 'Restarting SMART client.');
      SMART_Server := RandomWorld(Players[CurrentPlayer].Member);
      if not InitiateSMART then
      begin
        WriteString('MyLogin', 'Failed to restart SMART client.');
        Exit;
      end;
      // Reattempt login.
      Result := Login;
{$ENDIF}
    end;
  end;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function CheckRandoms: Boolean;
Contributors: Bixby Sayz
Description: Checks for randoms. Returns true on everything okay. Sets gametab
             to desired tab after solving random.
Date Created: 2012-01-02. By Bixby Sayz. RS2 Build 695.
Last Modification: 2012-01-26. By Bixby Sayz. RS2 Build 699.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
function CheckRandoms: Boolean;
var
  RandomFound: Boolean;  // Was a random found?
  I: Integer;            // Loop counter.
begin
  Result := False;
{$IFDEF DEBUG}
  WriteString('CheckRandoms', '');
{$ENDIF}

  // If we are not logged in it may be due to "runescape has been updated".
  if not LoggedIn then
  begin
{$IFDEF DEBUG}
    WriteString('CheckRandoms', 'Not logged in. Attempting login.');
{$ENDIF}
    if not MyLogin then
    begin
      WriteString('CheckRandoms', 'Failed login attempt.');
      Exit;
    end;
  end;

  // Bank screen hides tabs which will give a false positive for randoms.
  if BankScreen then
  begin
     // If this is called right after closing the bank we sometimes get a false
     // positive on the bank screen being open. Wait a sec then check that the
     // bank screen really is open before attempting to close it.
    WaitRR(250, 500);
    if BankScreen then
      CloseBank(True);
  end;

  with Players[CurrentPlayer] do
  begin

    // Check for randoms.
    Rand := '';
    RandomFound := OSIFindRandoms;
    Result := not RandomFound;
    if Result or (not LoggedIn) then
      Exit;

    // We found a random. Did we solve it?
    for I := 0 to High(RS2Randoms) do
      if (RS2Randoms[I].Name = Rand) then
        if RS2Randoms[I].InRandom() then
        begin
          WriteString('CheckRandoms', 'Failed to solve random: ' + Rand + '.');
          Status := 'Random';
          Exit;
        end;

    // If we did solve a random, then deal with reward box.
    WriteString('CheckRandoms', 'Successfully solved random: ' + Rand + '.');
    OverideRandInvTab := False;
    FindRandomEventGift;
    OverideRandInvTab := True;

    // Reset things back to the way they were prior to the random.
    Rand := '';
    if (Integers[IBNK] = Loc_SW) then
    begin
      MakeCompass(180);
      SetAngle(True);
    end
    else
      ClickCompass(True);
    SetGameTab(Tab_Magic);
  end;

  // Success.
  Result := True;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function WaitForTab(WhichTab: Integer; SwitchImmediately: Boolean): Boolean;
Contributors: Bixby Sayz
Description: Wait for desired gametab.
Date Created: 2012-01-06. By Bixby Sayz. RS2 Build 696.
Last Modification: 2012-01-13. By Bixby Sayz. RS2 Build 698.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
function WaitForTab(WhichTab: Integer; SwitchImmediately: Boolean): Boolean;
var
  I: Integer;  // Loop counter.
  T: Integer;  // Time counter.
begin
  Result := False;
{$IFDEF DEBUG}
  WriteString('WaitForTab', '');
{$ENDIF}

  // Wait for tab to become visible. (After banking the tabs take a second to
  // reappear)
  T := GetSystemTime + RandomRange(7500, 10000);
  repeat
    WaitRR(25, 50);
    if (GetSystemTime > T) then
      Exit;
  until TabExists(WhichTab);

  // Switch to game tab immediately or wait for it to switch on its own?
  if SwitchImmediately then
    SetGameTab(WhichTab);

  // Wait for game tab. If it doesn't appear, try to switch to it, then wait
  // again.
  for I := 0 to 1 do
  begin
    T := GetSystemTime + RandomRange(7500, 10000);
    repeat
      WaitRR(25, 50);
      if (GetSystemTime > T) then
        Break;
      Result := (GetCurrentTab = WhichTab);
    until Result;
    if Result then
      Exit;

    // If lag causees us to click a tab twice the game automaticaly switches to
    // the objectives tab (only happens on newer accounts. Doesn't affect older
    // accounts) Truly annoying. If this happens switch back to the tab we want.
    if (GetCurrentTab = Tab_Objectives) then
    begin
      SetGameTab(WhichTab);
      Continue;
    end;

    // If that isn't the case, then maybe a random got us?
    if (I = 0) then
    begin
      if not CheckRandoms then
        Exit;
      SetGameTab(WhichTab);
    end;
  end;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function CheckMembersWorld: Boolean;
Contributors: Bixby Sayz
Description: Reads world number from friends tab and determines if it is a
             members world.
Date Created: 2012-01-11. By Bixby Sayz. RS2 Build 697.
Last Modification: 2012-01-11. By Bixby Sayz. RS2 Build 697.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
function CheckMembersWorld: Boolean;
var
  S: String;       // World text read from screen.
  SLen: Integer;   // Length of world text.
  World: Integer;  // World number.
  HiRw: Integer;   // Size of world info array.
  I: Integer;      // Loop counter.
begin
  Result := False;
{$IFDEF DEBUG}
  WriteString('CheckMembersWorld', '');
{$ENDIF}
  // Check logged in.
  if not LoggedIn then
  begin
    WriteString('CheckMembersWorld', 'Not logged in.');
    Exit;
  end;

  // Switch to friends tab.
  if not WaitForTab(Tab_Friends, True) then
  begin
    WriteString('CheckMembersWorld', 'Failed to switch to friends tab.');
    Exit;
  end;
  // Read world text from friends tab.
  S := Trim(GetTextAtEx(660, 223, 10, LoginChars, False, False, 0, 2, 3381759, 4, True, tr_AllChars));
  SLen := Length(S);
  if (SLen = 0) then
  begin
    WriteString('CheckMembersWorld', 'Failed to read world number.');
    Exit;
  end;
  // Trim off leading spaces/garbage.
  for I := SLen downto 1 do
    if (S[I] < '0') or (S[I] > '9') then
      Break;
  if (I = SLen) then
  begin
    WriteString('CheckMembersWorld', 'Failed to read world number.');
    Exit;
  end;

  // Convert world to a number and look it up.
  World := StrToIntDef(Copy(S, (I + 1), (SLen - I)), 0);
  if (World = 0) then
  begin
    WriteString('CheckMembersWorld', 'Failed to read world number.');
    Exit;
  end;
  HiRw := High(RS2WorldArray);
  for I := 0 to HiRw do
    if (RS2WorldArray[I].Number = World) then
    begin
      Result := RS2WorldArray[I].Members;
      Exit;
    end;

  // We failed to lookup world.
  WriteString('CheckMembersWorld', 'Failed to lookup world number.');
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function GetClickPattern(NumOres: Integer; Members: Boolean): TIntegerArray;
Contributors: Bixby Sayz
Description: Determines optimal click pattern for x number of ores.
Date Created: 2012-01-02. By Bixby Sayz. RS2 Build 695.
Last Modification: 2012-01-11. By Bixby Sayz. RS2 Build 697.
Note: Assumes nature runes in slot 0 and magic tab will be sorted to match the
      click pattern.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
function GetClickPattern(NumOres: Integer): TIntegerArray;
var
  I: Integer;  // Loop counter.
begin
  Result := [];
  if (NumOres < 1) or (NumOres > 27) then
    Exit;

  // Determine optimal click pattern.
  case NumOres of
    3: Result := [3, 3, 3];
    5: Result := [5, 5, 5, 5, 5];
    9: Result := [9, 9, 9, 9, 9, 9, 9, 9, 9];
    13: Result := [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13];
    27: Result := [22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
                   22, 22, 22, 22, 22 ,22, 22, 25, 25, 25, 26, 27]
    // Failsafe. Simply click on the last ore until done.
    else
    begin
      SetLength(Result, NumOres);
      for I := 0 to (NumOres - 1) do
        Result[I] := NumOres;
    end;
  end;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function GetSortOrder(NumOres: Integer; Members: Boolean; out Options: TBooleanArray; out SortOrder): Boolean;
Contributors: Bixby Sayz
Description: Determines optimal sort order options for magic tab.
Date Created: 2012-01-11. By Bixby Sayz. RS2 Build 697.
Last Modification: 2012-01-11. By Bixby Sayz. RS2 Build 697.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
function GetSortOrder(NumOres: Integer; Members: Boolean; out Options: TBooleanArray; out SortOrder: String): Boolean;
begin
  Result := False;
{$IFDEF DEBUG}
  WriteString('GetSortOrder', '');
{$ENDIF}

  // Get sort order.
  case NumOres of
    3: if Members then
       begin
         Options := [False, False, False, True, True];
         SortOrder := 'level';
       end
       else
       begin
         Options := [False, False, False, False, True];
         SortOrder := 'teleport';
       end;
    5: begin
         if Members then
           Options := [False, False, True, False, True]
         else
           Options := [False, True, False, False, True];
         SortOrder := 'level';
       end;
    9: begin
         Options := [False, True, True, False, True];
         SortOrder := 'teleport';
       end;
    13: begin
          Options := [False, True, True, True, True];
          if Members then
            SortOrder := 'teleport'
          else
            SortOrder := 'level';
        end;
    27: begin
          Options := [False, True, True, True, True];
          SortOrder := 'combat';
       end;
    // Failsafe. Simply set things back to defaults.
    else
    begin
      Options := [False, True, True, True, True];
      SortOrder := 'level';
    end;
  end;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function SetMagicOptions(Defensive, Combat, Teleport, Miscellaneous, Skill: Boolean; SortOrder: String): Boolean;
Contributors: Bixby Sayz
Description: Toggles displays/sort order options of magic tab.
Date Created: 2012-01-08. By Bixby Sayz. RS2 Build 696.
Last Modification: 2012-01-10. By Bixby Sayz. RS2 Build 696.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
function SetMagicOptions(Options: TBooleanArray; SortOrder: String): Boolean;
var
  Buttons: TBoxArray;   // Dimensions of buttons along the bottom.
  SortButton: Integer;  // Which sort button to click.
  I: Integer;           // Loop counter.
begin
  Result := False;
{$IFDEF DEBUG}
  WriteString('SetMagicOptions', '');
{$ENDIF}

  // Setup buttons.
  //          defensive casting             show/hide combat spells
  //          show/hide teleport spells     show/hide miscellaneous spells
  //          show/hide skill spells        sort by level order
  //          sort by combat first          sort by teleports first
  Buttons := [IntToBox(553, 441, 572, 460), IntToBox(583, 441, 602, 460),
              IntToBox(604, 441, 623, 460), IntToBox(625, 441, 644, 460),
              IntToBox(646, 441, 665, 460), IntToBox(674, 441, 693, 460),
              IntToBox(693, 441, 712, 460), IntToBox(712, 441, 731, 460)];

  // Check logged in.
  if not LoggedIn then
  begin
    WriteString('SetMagicOptions', 'Not logged in.');
    Exit;
  end;
  // Check options.
  if (Length(Options) <> 5) then
  begin
    WriteString('SetMagicOptions', 'Invalid number of options (' + IntToStr(Length(Options)) + ').');
    Exit;
  end;

  // Switch to magic tab.
  if not WaitForTab(Tab_Magic, True) then
  begin
    WriteString('SetMagicOptions', 'Failed to switch to magic tab.');
    Exit;
  end;

  // Run throught the options. (Defensive, Combat, Teleport, Miscellaneous, Skill)
  for I := 0 to 4 do
    if (Options[I] xor SimilarColors(GetColor(Buttons[I].X1, (Buttons[I].Y1 + 10)), 16711422, 5)) then
      MouseBox((Buttons[I].X1 + 2), (Buttons[I].Y1 + 2), (Buttons[I].X2 - 2), (Buttons[I].Y2 - 2), ClickLeft);

  // Set sort order.
  case LowerCase(SortOrder) of
    'level': SortButton := 5;
    'combat': SortButton := 6;
    'teleport': SortButton := 7;
    else
    begin
      WriteString('SetMagicOptions', 'Invalid sort order (' + SortOrder + ').');
      Exit;
    end;
  end;

  // Click appropriate sort order button.
  if not SimilarColors(GetColor((Buttons[SortButton].X1 + 10), Buttons[SortButton].Y1), 16711422, 5) then
    MouseBox((Buttons[SortButton].X1 + 2), (Buttons[SortButton].Y1 + 2), (Buttons[SortButton].X2 - 2), (Buttons[SortButton].Y2 - 2), ClickLeft);

  // Ensure magic list is scrolled all the way to the top.
  if SimilarColors(GetColor(728, 226), 2041131, 5) then
    HoldMouseWaitBox(723, 209, 732, 218, 1500, 2000, True);

  // Success.
  Result := True;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure CalcExpPerHour;
Contributors: Bixby Sayz
Description: Calculate experience gain, experience per hour, etc.
Date Created: 2012-01-08, By Bixby Sayz. RS2 Build 696.
Last Modification: 2012-01-13, By Bixby Sayz. RS2 Build 698.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
procedure CalcExpPerHour;
var
  T: Integer;  // Time counter.
begin
  with Players[CurrentPlayer] do
  begin
    // Time worked.
    T := (Worked + (GetSystemTime - PlayerStartTime));
    // Magic experience/level.
    TIA[TISTAT][IMXP] := (TIA[TISTAT][IBM] * 53);
    TIA[TISTAT][ICME] := (TIA[TISTAT][ISME] + TIA[TISTAT][IMXP]);
    TIA[TISTAT][IMLV] := (Level[Skill_Magic] - TIA[TISTAT][ISML]);
    // Smithing experience/level.
    TIA[TISTAT][ISXP] := Round(TIA[TISTAT][IBM] * Extendeds[ESXP]);
    TIA[TISTAT][ICSE] := (TIA[TISTAT][ISSE] + TIA[TISTAT][ISXP]);
    TIA[TISTAT][ISLV] := (Level[Skill_Smithing] - TIA[TISTAT][ISSL]);
    // Total experience.
    TIA[TISTAT][ITXP] := TIA[TISTAT][IMXP] + TIA[TISTAT][ISXP];
    // Experience per hour.
    if (T > 0) then
    begin
      TIA[TISTAT][IMPH] := Round(TIA[TISTAT][IMXP] / (T * 1.0) * 3600000.0)
      TIA[TISTAT][ISPH] := Round(TIA[TISTAT][ISXP] / (T * 1.0) * 3600000.0)
      TIA[TISTAT][ITPH] := Round(TIA[TISTAT][ITXP] / (T * 1.0) * 3600000.0)
    end
    else
    begin
      TIA[TISTAT][IMPH] := 0;
      TIA[TISTAT][ISPH] := 0;
      TIA[TISTAT][ITPH] := 0;
    end;
  end;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure GetPlayerExpLevels;
Contributors: Bixby Sayz
Description: Get current experience and levels.
Date Created: 2012-01-04, By Bixby Sayz. RS2 Build 696.
Last Modification: 2012-01-26, By Bixby Sayz. RS2 Build 699.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
procedure GetPlayerExpLevels;
var
  MagicXp: Integer;  // Magic experience.
  SmithXp: Integer;  // Smithing experience.
  I: Integer;        // Loop counter.
begin
{$IFDEF DEBUG}
  WriteString('GetPlayerExpLevels', '');
{$ENDIF}
  // Check logged in.
  if not LoggedIn then
  begin
    WriteString('GetPlayerExpLevels', 'Not logged in.');
    Exit;
  end;
  if BankScreen then
    CloseBank(True);

  with Players[CurrentPlayer] do
  begin
    if not WaitForTab(Tab_Stats, True) then
    begin
      WriteString('GetPlayerExpLevels', 'Failed to switch to stats tab.');
      Exit;
    end;
    GetAllLevels;
    // OSI sometimes fails to read experience. Wrap in a loop to work around
    // this.
    for I := 0 to 1 do
    begin
      MagicXp := GetXP(Skill_Magic);
      if (MagicXp > (-1)) then
        Break;
    end;

    // OSI sometimes fails to read experience. Wrap in a loop to work around
    // this.
    for I := 0 to 1 do
    begin
      SmithXp := GetXP(Skill_Smithing);
      if (SmithXp > (-1)) then
        Break;
    end;

{$IFDEF DEBUG}
  WriteString('GetPlayerExpLevels', Format('Magic Exp: %d, Smithing Exp: %d.', [MagicXp, SmithXp]));
{$ENDIF}
    if (MagicXp < 1) or (SmithXp < 1) then
    begin
      WriteString('GetPlayerExpLevels', 'Failed to read experience.');
      // Fall back to calculations if reading experience fails.
      if (TIA[TISTAT][ISME] > 0) then
      begin
        MagicXp := TIA[TISTAT][ICME];
        SmithXp := TIA[TISTAT][ICSE];
        Level[Skill_Magic] := TIA[TISTAT][ISML];
        Level[Skill_Smithing] := TIA[TISTAT][ISSL];
      end
      else
        Exit;
    end;

    // Get starting experience/levels.
    if (TIA[TISTAT][ISML] = 0) then
    begin
      TIA[TISTAT][ISME] := MagicXp;
      TIA[TISTAT][ISML] := Level[Skill_Magic];
      TIA[TISTAT][ISSE] := SmithXp;
      TIA[TISTAT][ISSL] := Level[Skill_Smithing];
    end;

    // Update experience/levels gained.
    TIA[TISTAT][ICME] := MagicXp;
    TIA[TISTAT][ICSE] := SmithXp;
  end;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure DoReport;
Contributors: Bixby Sayz
Description: Progress report.
Date Created: 2012-01-04. By Bixby Sayz. RS2 Build 696.
Last Modification: 2012-01-13. By Bixby Sayz. RS2 Build 698.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
procedure DoReport(ReportType: String);
var
  TR: Integer;        // Total time running.
  Hr: Integer;        // Hours.
  Mn: Integer;        // Minutes.
  Sc: Integer;        // Seconds.
  S: String;          // Report.
  SA: TStringArray;   // Expanded report.
  CW: Integer;        // Time worked current player.
  HiPlayer: Integer;  // Size of player array.
  I: Integer;         // Loop counter.
  T: Integer;         // Time counter.
begin
  // Get time running.
  TR := GetTimeRunning;
  ConvertTime(TR, Hr, Mn, Sc);
  CW := (Players[CurrentPlayer].Worked + (GetSystemTime - PlayerStartTime));

  // Script title.
  S := '~'
     + Format('%s v%s (%s) by %s~', [SCRIPT_NAME, SCRIPT_VERSION, SCRIPT_DATE, SCRIPT_AUTHOR])
     + Format('Time Running: %.2dh %.2dm %.2ds~', [Hr, Mn, Sc])
     + '~';

  // Long report.
  if (LowerCase(ReportType) = 'long') or (LowerCase(ReportType) = 'both') then
  begin
    S := S + '+--------------+----------+----------+----------+--------+---------+---------+---------+-------+-------+----------+----------+----------+~';
    S := S + '| Name         | Status   | Worked   | Bar Type | Made   | M Exp   | S Exp   | T Exp   | M Lvl | S Lvl | M Exp/Hr | S Exp/Hr | T Exp/Hr |~';
    S := S + '+--------------+----------+----------+----------+--------+---------+---------+---------+-------+-------+----------+----------+----------+~';

    HiPlayer := High(Players);
    for I := 0 to HiPlayer do
      with Players[I] do
      begin
        if (I = CurrentPlayer) then
          T := CW
        else
          T := Worked;
        ConvertTime(T, Hr, Mn, Sc);
        S := S + '| ' + Padr(Name, 13)
           + '| ' + Padr(Status, 9)
           + '| ' + Format('%.2d:%.2d:%.2d', [Hr, Mn, Sc])
           + ' | ' + Padr(Strings[SBAR], 9)
           + '| ' + Padr(GroupDigits(TIA[TISTAT][IBM]), 7)
           + '| ' + Padr(GroupDigits(TIA[TISTAT][IMXP]), 8)
           + '| ' + Padr(GroupDigits(TIA[TISTAT][ISXP]), 8)
           + '| ' + Padr(GroupDigits(TIA[TISTAT][ITXP]), 8)
           + '| ' + Padr(GroupDigits(TIA[TISTAT][IMLV]), 6)
           + '| ' + Padr(GroupDigits(TIA[TISTAT][ISLV]), 6)
           + '| ' + Padr(GroupDigits(TIA[TISTAT][IMPH]), 9)
           + '| ' + Padr(GroupDigits(TIA[TISTAT][ISPH]), 9)
           + '| ' + Padr(GroupDigits(TIA[TISTAT][ITPH]), 9)
           + '|~';
        S := S + '+--------------+----------+----------+----------+--------+---------+---------+---------+-------+-------+----------+----------+----------+~';
      end;
    S := S + '~';
  end;

  // Short report.
  if (LowerCase(ReportType) = 'short') or (LowerCase(ReportType) = 'both') then
  begin
    with Players[CurrentPlayer] do
    begin
      ConvertTime(CW, Hr, Mn, Sc);
      S := S + '+----------------+---------------------+~'
         + '| Current Player | ' + Padr(Name, 20) + '|~'
         + '+----------------+---------------------+~'
         + '|         Status | ' + Padr(Status, 20) + '|~'
         + '|         Worked | ' + Padr(Format('%.2d:%.2d:%.2d', [Hr, Mn, Sc]), 20) + '|~'
         + '|         Banked | ' + Padr(GroupDigits(Banked), 20) + '|~'
         + '|            Bar | ' + Padr(Strings[SBAR], 20) + '|~'
         + '|           Made | ' + Padr(GroupDigits(TIA[TISTAT][IBM]), 20) + '|~'
         + '|      Magic Exp | ' + Padr(GroupDigits(TIA[TISTAT][IMXP]) + ' (' + GroupDigits(TIA[TISTAT][IMPH]) + '/hr)', 20) + '|~'
         + '|   Smithing Exp | ' + Padr(GroupDigits(TIA[TISTAT][ISXP]) + ' (' + GroupDigits(TIA[TISTAT][ISPH]) + '/hr)', 20) + '|~'
         + '|      Total Exp | ' + Padr(GroupDigits(TIA[TISTAT][ITXP]) + ' (' + GroupDigits(TIA[TISTAT][ITPH]) + '/hr)', 20) + '|~'
         + '|     Magic Lvls | ' + Padr(GroupDigits(TIA[TISTAT][IMLV]), 20) + '|~'
         + '|  Smithing Lvls | ' + Padr(GroupDigits(TIA[TISTAT][ISLV]), 20) + '|~'
         + '+----------------+---------------------+~'
         + '~';
    end;
  end;

  // Output report.
{$IFNDEF DEBUG}
  ClearReport;
{$ENDIF}
  SA := Explode('~', S);
  for I := 0 to High(SA) do
  begin
{$IFDEF DEBUG}
    WriteLn(SA[I]);
{$ELSE}
    AddToReport(SA[I]);
{$ENDIF}
  end;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure TakeABreak(TimeToBreak: Integer);
Contributors: Bixby Sayz
Description: Takes a break.
Date Created: 2012-01-08. By Bixby Sayz. RS2 Build 695.
Last Modification: 2012-01-08. By Bixby Sayz. RS2 Build 696.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
procedure TakeABreak(TimeToBreak: Integer);
var
  CT: Integer;  // Current time.
  Hr: Integer;  // Hours.
  Mn: Integer;  // Minutes.
  Sc: Integer;  // Seconds.
  I: Integer;   // Loop counter.
  T: Integer;   // Time counter.
begin
{$IFDEF DEBUG}
  WriteString('TakeABreak', '');
{$ENDIF}

  ConvertTime(TimeToBreak, Hr, Mn, Sc);
  WriteString('TakeABreak', Format('Time remaining: %.2d:%.2d:%.2d', [Hr, Mn, Sc]));

  I := 0;
  T := GetSystemTime;
  repeat
    WaitRR(750, 100);
    CT := (GetSystemTime - T);
    if  ((CT div 30000) > I) then
      if ((TimeToBreak - CT) > 0) then
      begin
        ConvertTime((TimeToBreak - CT), Hr, Mn, Sc);
        WriteString('TakeABreak', Format('Time remaining: %.2d:%.2d:%.2d', [Hr, Mn, Sc]));
        Inc(I);
      end;
  until (GetSystemTime > (T + TimeToBreak));
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function FindBankChest(out Loc: TPoint): Boolean;
Contributors: Bixby Sayz
Description: Finds bank chest.
Date Created: 2012-01-25. By Bixby Sayz. RS2 Build 699.
Last Modification: 2012-01-25. By Bixby Sayz. RS2 Build 699.
Note: Only tested on soul wars bank chest.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
function FindBankChest(out Loc: TPoint): Boolean;
var
  OldCTS: Integer;      // Previous color tolerance speed (CTS).
  OldHueMod: Extended;  // Previous hue modifier.
  OldSatMod: Extended;  // Previous saturation modifier.
  TPA: TPointArray;     // Points matching bank chest color.
  ATPA: T2DPointArray;  // Combined list of points.
  HiATPA: Integer;      // Size of points array.
  B: TBox;              // Location of bank chest.
  P: TPoint;            // Location of bank chest.
  I: Integer;           // Loop counter.
begin
  Result := False;
  Loc := Point(0, 0);
{$IFDEF DEBUG}
  WriteString('FindBankChest', '');
{$ENDIF}
  // Check logged in.
  if not LoggedIn then
  begin
    WriteString('FindBankChest', 'Not logged in.');
    Exit;
  end;

  // Setup color finding.
  OldCTS := GetColorToleranceSpeed;
  GetColorspeed2Modifiers(OldHueMod, OldSatMod);
  ColorToleranceSpeed(2);

  // Wrap in try...finally to make sure we set things back. (This does slow
  // things down a bit)
  try

    // Find bank chest color.
{$IFDEF DEBUG}
    WriteString('FindBankChest', 'Find bank chest gray color.');
{$ENDIF}
    SetColorSpeed2Modifiers(0.35, 0.25);
    if not FindColorsTolerance(TPA, 10790060, MSX1, MSY1, MSX2, MSY2, 7) then
    begin
      WriteString('FindBankChest', 'Failed to find gray color.');
      Exit;
    end;
{$IFDEF DEBUG}
    WriteString('FindBankChest', IntToStr(Length(TPA)) + ' points found.');
{$ENDIF}

  finally
    // Set color finding back to the way we found it.
    SetColorSpeed2Modifiers(OldHueMod, OldSatMod);
    ColorToleranceSpeed(OldCTS);
  end;

  // Group colors according to proximity and sort by distance from center of
  // main screen.
  ATPA := SplitTPA(TPA, 10);
  HiATPA := High(ATPA);
  if (HiATPA  < 0) then
  begin
    WriteString('FindBankChest', 'Failed to group colors.');
    Exit;
  end;
  SortATPAByMiddleEx(ATPA, Point(MSCX, MSCY));
{$IFDEF DEBUG}
  WriteString('FindBankChest', IntToStr(HiATPA + 1) + ' groupings.');
{$ENDIF}

  // Loop through each group.
  for I := 0 to HiATPA do
  begin
    // Move mouse to bank chest and check uptext.
    B := TPABounds(ATPA[I]);
    MouseBox(B.X1, B.Y1, B.X2, B.Y2, MoveTo);
    WaitRR(250, 500);
    GetMousePos(P.X, P.Y);
{$IFDEF DEBUG}
    WriteString('FindBankChest', Format('Evaluating point (%d,%d). Uptext: "%s".', [P.X, P.Y, GetUpText]));
{$ENDIF}
    Result := IsUpTextMulti(['Bank', 'chest', 'hest']);
    if Result then
    begin
{$IFDEF DEBUG}
      WriteString('FindBankChest', Format('Found bank chest at (%d,%d).', [P.X, P.Y]));
{$ENDIF}
      Loc := P;
      Exit;
    end;
  end;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function OpenBankChest: Boolean;
Contributors: Bixby Sayz
Description: Finds bank chest.
Date Created: 2012-01-25. By Bixby Sayz. RS2 Build 699.
Last Modification: 2012-01-25. By Bixby Sayz. RS2 Build 699.
Note: Currently only supports soul wars bank chest.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
function OpenBankChest: Boolean;
var
  P: TPoint;  // Location of bank chest.
begin
  Result := False;
{$IFDEF DEBUG}
  WriteString('OpenBankChest', '');
{$ENDIF}
  // Check logged in.
  if not LoggedIn then
  begin
    WriteString('OpenBankChest', 'Not logged in.');
    Exit;
  end;

  // Find bank chest color.
{$IFDEF DEBUG}
  WriteString('OpenBankChest', 'Find bank chest.');
{$ENDIF}
  if not FindBankChest(P) then
  begin
    WriteString('OpenBankChest', 'Failed to find bank chest.');
    Exit;
  end;

  // Right click on bank chest.
  Mouse(P.X, P.Y, 0, 0, False);

  // Wait for menu to appear.
{$IFDEF DEBUG}
  WriteString('OpenBankChest', 'Wait for menu.');
{$ENDIF}
  if not WaitFunc(@OptionBoxExists, True, 25, 50, 7500, 10000) then
  begin
    WriteString('OpenBankChest', 'Failed to open menu.');
    Exit;
  end;

  // Select "Use Bank chest" option.
{$IFDEF DEBUG}
  WriteString('OpenBankChest', 'Select "use".');
{$ENDIF}
  if not ChooseOptionMulti(['Bank', 'chest']) then
  begin
    WriteString('OpenBankChest', 'Failed to choose option.');
    Exit;
  end;

  // Wait for bank screen to open.
  Result := WaitFunc(@BankScreen, True, 25, 50, 7500, 10000);
{$IFDEF DEBUG}
  WriteString('OpenBankChest', 'Bank chest open: ' + BoolToStr(Result) + '.');
{$ENDIF}
  if not Result then
  begin
    WriteString('OpenBankChest', 'Failed to open bank chest.');
    Exit;
  end;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function MyWithdraw(Amount: Integer; Coords: TPoint): Boolean;
Contributors: Bixby Sayz
Description: Withdraws item.
Date Created: 2012-01-04, By Bixby Sayz. RS2 Build 696.
Last Modification: 2012-01-04, By Bixby Sayz. RS2 Build 696.
Note: OSI's withdraw will miscalculate the bounds of the item if there are
      several tab separators visible on the screen, throwing the calculations
      off. This is a workaround.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
function MyWithdraw(Amount: Integer; Coords: TPoint): Boolean;
var
  TextTPA: TPointArray;  // All points matching color of text.
  P: TPoint;             // Position of text on screen.
  T: Integer;            // Time counter.
begin
  Result := False;
{$IFDEF DEBUG}
  WriteString('MyWithdraw', '');
{$ENDIF}
  if not BankScreen then
  begin
    WriteString('MyWithdrawDTM', 'Bank not open.');
    Exit;
  end;

  // Right click and wait for options menu.
  Mouse(Coords.X, Coords.Y, 10, 10, False);
  if not WaitFunc(@OptionBoxExists, True, 25, 50, 7500, 10000) then
  begin
    WriteString('MyWithdrawDTM', 'Menu failed to appear.');
    Exit;
  end;

  // Withdraw all?
  if (Amount = Withdraw_All) then
    ChooseOption('draw-All')

  // Withdraw all but one?
  else
    if (Amount = Withdraw_All_But_One) then
      ChooseOption('draw-All but one')

    // Does withdraw-amount exist?
    else
      if OptionExists('draw-' + IntToStr(Amount)) then
        ChooseOption('draw-' + IntToStr(Amount))

      // Select "withdraw-x".
      else
      begin
        if not ChooseOption('draw-X') then
        begin
          WriteString('MyWithdrawDTM', 'Withdraw-X option doesn''t exist.');
          Exit;
        end;

        // Wait for "Enter amount" text appear.
        T := GetSystemTime + RandomRange(7500, 10000);
        repeat
          WaitRR(25, 50);
          if (GetSystemTime > T) then
          begin
            WriteString('MyWithdrawDTM', '''Enter Amount'' failed to appear.');
            Exit;
          end;
          FindColors(TextTPA, 0, MCX1, MCY1, MCX2, MCY2);
        until FindTextTPAinTPA('Enter', ScreenChars, TextTPA, P.X, P.Y);

        WaitRR(25, 50);

        // Type in amount to withdraw.
        TypeSend(IntToStr(Amount));
      end;

  // Success.
  Result := True;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function DoBanking: Boolean;
Contributors: Bixby Sayz
Description: Bank bars and withdraw ores.
Date Created: 2012-01-01. By Bixby Sayz. RS2 Build 695.
Last Modification: 2012-01-25. By Bixby Sayz. RS2 Build 699.
Note: Assumes nature runes will be in inventory slot 0.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
function DoBanking: Boolean;
var
  P: TPoint;                // Position of item on screen.
  Amount: Integer;          // Amount to withdraw.
  PriSlots: TIntArray;      // Slots of primary ore in inventory.
  LenPri: Integer;          // Length of pimary ore array.
  SecSlots: TIntArray;      // Slots of secondary ore in inventory.
  LenSec: Integer;          // Length of secondary ore array.
  ExcludeSlots: TIntArray;  // Inventory slots to not deposit.
  I: Integer;               // Loop counter.
  T: Integer;               // Time counter.
begin
  Result := False;
{$IFDEF DEBUG}
  WriteString('DoBanking', '');
{$ENDIF}

  with Players[CurrentPlayer] do
  begin
    // Open bank. During testing 80 percent of all randoms came when clicking
    // on bank booth to open bank, so adjust for that.
    for I := 0 to 1 do
    begin
      if (Integers[IBNK] = Loc_SW) then
      begin
{$IFDEF DEBUG}
        WriteString('DoBanking', 'Open bank chest.');
{$ENDIF}
        OpenBankChest;
      end
      else
      begin
{$IFDEF DEBUG}
        WriteString('DoBanking', 'Open bank.');
{$ENDIF}
        OpenBank(Integers[IBNK]);
      end;
      T := GetSystemTime + RandomRange(7500, 10000);
      repeat
        WaitRR(25, 50);
        if (GetSystemTime > T) then
          Break;
      until BankScreen;
      if BankScreen then
        Break;
      if not CheckRandoms then
        Exit;
    end;
    if not BankScreen then
    begin
      WriteString('DoBanking', 'Failed to open bank.');
      Exit;
    end;

    // wrap in a try...finally to ensure we close the bank.
    try
      // Count bars made and update stats. This will be only approximate since
      // we are calculating rather than actually reading from stats tab.
      Inc(Banked);
      Amount := CountInvItemsDTM(Integers[IBAR]);
      IncEx(TIA[TISTAT][IBM], Amount);

      // Exclude nature rune in slot 0 when depositing.
      ExcludeSlots := [0];

      // Count primary ore in inventory. If we already have ores in inventory
      // then don't deposit them. Slows us down a bit searching, but more
      // human like.
      PriSlots := FindInvItemsDTM(Integers[IPRI]);
      LenPri := Length(PriSlots);
      if (LenPri = Integers[IBPT]) then
        for I := 0 to (LenPri - 1) do
          TIAAppend(ExcludeSlots, PriSlots[I]);

      // Find secondary ore in inventory. We can speed up banking a bit by not
      // depositing left over secondary ore each trip. One exception: If we
      // don't have enough room to withdraw primary ore then simply bank them
      // all.
      if Booleans[BSEC] then
      begin
        SecSlots := FindInvItemsDTM(Integers[ISEC]);
        LenSec := Length(SecSlots);
        if ((28 - LenSec - 1) >= Integers[IBPT]) then
          if (LenSec > 0) then
            for I := 0 to (LenSec - 1) do
              TIAAppend(ExcludeSlots, SecSlots[I]);
      end;

      // Deposit items.
      if (Length(ExcludeSlots) < 28) then
      begin
{$IFDEF DEBUG}
        WriteString('DoBanking', 'Deposit items.');
{$ENDIF}
        if not DepositAllExclude(ExcludeSlots, True) then
        begin
          WriteString('DoBanking', 'Failed to deposit items.');
          Exit;
        end;
      end;

      // Do we even need to withdraw? If we have our primary ores, and the rest
      // of inventory is filled with secondar ore, then we are done.
      if (LenPri = Integers[IBPT]) and ((not  Booleans[BSEC]) or InvFull) then
      begin
        Result := True;
        Exit;
      end;

      // Withdraw primary ore.
      if (LenPri <> Integers[IBPT]) then
      begin
{$IFDEF DEBUG}
        WriteString('DoBanking', 'Withdraw primary ore.');
{$ENDIF}
        if (Integers[IBPT] = 27) then
          Amount := Withdraw_All
        else
          Amount := Integers[IBPT];
        if FindDTM(Integers[IPRI], P.X, P.Y, MBX1, MBY1, MBX2, MBY2) then
          Result := MyWithdraw(Amount, P);
        if not Result then
        begin
          WriteString('DoBanking', 'Failed to withdraw primary ore.');
          Exit;
        end;
      end;

      // Wait for primary ore to appear in inventory.
      T := GetSystemTime + RandomRange(7500, 10000);
      repeat
        WaitRR(25, 50);
        if (GetSystemTime > T) then
        begin
          WriteString('DoBanking', 'Timed out waiting for primary ore to appear in inventory.');
          Exit;
        end;
        Result := (CountInvItemsDTM(Integers[IPRI]) > 0);
      until Result;

      // If we attempt a second withdraw before the menu from the first attempt
      // completely disappears it will fail. Wait for menu to go away.
      WaitFunc(@OptionBoxExists, False, 25, 50, 7500, 10000);

      // If mouse is hovering over buttons at bottom of bank popup can obscure
      // our ore.
      if PointInBox(P, Box(MBX1, MBY2, MBX2, (MBY2 + 30))) then
      begin
{$IFDEF DEBUG}
        WriteString('DoBanking', 'Move mouse.');
{$ENDIF}
        MouseBox((MBX1 + 25), (MBY1 + 25), (MBX2 - 25), (MBY2 - 25), MoveTo);
        WaitRR(75, 100);
      end;

      // Withdraw secondary ore.
      if Booleans[BSEC] and (not InvFull) then
      begin
{$IFDEF DEBUG}
        WriteString('DoBanking', 'Withdraw secondary ore.');
{$ENDIF}
        if FindDTM(Integers[ISEC], P.X, P.Y, MBX1, MBY1, MBX2, MBY2) then
          Result := MyWithdraw(Withdraw_All, P);
        if not Result then
        begin
          WriteString('DoBanking', 'Failed to withdraw secondary ore.');
          Exit;
        end;

        // Wait for secondary ore to appear in inventory.
        T := GetSystemTime + RandomRange(7500, 10000);
        repeat
          WaitRR(25, 50);
          if (GetSystemTime > T) then
          begin
            WriteString('DoBanking', 'Timed out waiting for secondary ore to appear in inventory.');
            Exit;
          end;
          Result := (CountInvItemsDTM(Integers[ISEC]) > 0);
        until Result;

        // Count primary ores and generate optimized click pattern.
        // This allows us to adapt to the situation where some but not all of
        // the primary ore was withdrawn (because we ran out of ore).
        TIA[TICLK] := GetClickPattern(CountInvItemsDTM(Integers[IPRI]));

        // Sanity check. If there are no secondary ores in inventory we have
        // a problem.
        if Booleans[BSEC] then
        begin
          Result := (CountInvItemsDTM(Integers[ISEC]) > 0);
          if not Result then
          begin
            WriteString('DoBanking', 'no secondary ore in inventory.');
            Exit;
          end;
        end;
      end;

    finally
      // Close bank.
      if BankScreen then
        CloseBank(True);
      // Gametabs are hidden when we bank and reappear when we close the bank.
      // Wait for them to reappear so we don't get a false positive on random
      // checking if we check for a random right afterwards.
      T := GetSystemTime + RandomRange(7500, 10000);
      repeat
        WaitRR(25, 50);
        if (GetSystemTime > T) then
        begin
          WriteString('DoBanking', 'Failed to close bank.');
          Exit;
        end;
      until TabExists(Tab_Magic);
    end;
  end;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function DoSuperHeat: Boolean;
Contributors: Bixby Sayz
Description: Superheats ores in inventory.
Date Created: 2012-01-01. By Bixby Sayz. RS2 Build 695.
Last Modification: 2012-01-11. By Bixby Sayz. RS2 Build 697.
Note: Assumes nature runes will be in inventory slot 0.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
function DoSuperHeat: Boolean;
var
  B: TBox;                 // Bounds of inventory item.
  P: TPoint;               // Actual point to click.
  I: Integer;              // Loop counter.
  J: Integer;              // Loop counter.
begin

  Result := False;
{$IFDEF DEBUG}
  WriteString('DoSuperHeat', '');
{$ENDIF}

  // Loop through click pattern.
  with Players[CurrentPlayer] do
    for I := 0 to High(TIA[TICLK]) do
    begin
      // Move mouse to spell icon first to save a little time.
{$IFDEF DEBUG}
      WriteString('DoSuperHeat', 'Move mouse to spell.');
{$ENDIF}
      P.X := RandomRange((TIA[TIOTH][ISHX] - 5), (TIA[TIOTH][ISHX] + 5));
      P.Y := RandomRange((TIA[TIOTH][ISHY] - 5), (TIA[TIOTH][ISHY] + 5));
      MMouse(P.X, P.Y, 0, 0);

      // Now wait for magic tab. This includes a check for randoms so no need to
      // do one here.
      if not WaitForTab(Tab_Magic, False) then
      begin
        WriteString('DoSuperHeat', 'Failed to switch to magic tab.');
        Exit;
      end;

      // Check superheat spell is enabled (we have runes).
      for J := 0 to 4 do
      begin
        if SimilarColors(11594734, GetColor(TIA[TIOTH][ISHX], TIA[TIOTH][ISHY]), 10) then
          Break;
        WaitRR(200, 300);
      end;
      if (J > 4) then
      begin
        WriteString('DoSuperHeat', 'Spell not available. Out of runes?');
        Exit;
      end;

      // Check for level up from previous cast. If we check before this we may
      // miss it by checking before the level message has time to appear on
      // the screen.
      if LeveledUp then
      begin
        WriteString('DoSuperHeat', 'Level up detected.');
        WaitForTab(Tab_Magic, True);
      end;

      // Click on spell.
{$IFDEF DEBUG}
      WriteString('DoSuperHeat', 'Click spell icon.');
{$ENDIF}
      Mouse(P.X, P.Y, 0, 0, True);

      // Move mouse to ore first to save a little time.
{$IFDEF DEBUG}
      WriteString('DoSuperHeat', 'Move mouse to item slot ' + IntToStr(TIA[TICLK][I]) + '.');
{$ENDIF}
      B := GetItemBounds(TIA[TICLK][I]);
      P.X := RandomRange((B.X1 + 4), (B.X2 - 4));
      P.Y := RandomRange((B.Y1 + 4), (B.Y2 - 4));
      MMouse(P.X, P.Y, 0, 0);

      // Now wait for inventory tab. This includes a check for randoms so no need
      // to do one here.
      if not WaitForTab(Tab_Inv, False) then
      begin
        WriteString('DoSuperHeat', 'Failed to switch to inventory tab.');
        Exit;
      end;

      // Click on ore.
{$IFDEF DEBUG}
      WriteString('DoSuperHeat', 'Click ore.');
{$ENDIF}

      Mouse(P.X, P.Y, 0, 0, True);
    end;

    // If we leveled up on the very last cast it will be missed in the loop
    // above. Make one last check for level.
    if LeveledUp then
    begin
      WriteString('DoSuperHeat', 'Level up detected.');
      WaitForTab(Tab_Magic, True);
    end;

  // Success.
  Result := True;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function SetupPlayer: Boolean;
Contributors: Bixby Sayz
Description: Load dtms, and calculate how many bars per load for current player.
Date Created: 2012-01-01. By Bixby Sayz. RS2 Build 695.
Last Modification: 2012-01-12. By Bixby Sayz. RS2 Build 698.
Note: Assumes nature runes will be in inventory slot 0. (Which affects how many
      bars we can make each trip)
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
function SetupPlayer: Boolean;
var
  Options: TBooleanArray;  // Magic options.
  SortOrder: String;       // Magic sort order.
  DTM: Integer;            // Superheat spell icon.
  P: TPoint;               // Location of superheat spell icon.
  Tol: Integer;            // Bitmap tolerance. Not used.
  I: Integer;              // Loop counter.
begin
  Result := False;
{$IFDEF DEBUG}
  WriteString('SetupPlayer', '');
{$ENDIF}

  with Players[CurrentPlayer] do
  begin
    // Figure out what ores to use, how many ores per trip, and load dtms.
    case LowerCase(Strings[SBAR]) of
      'bronze': begin
                  Integers[IPRI] := LoadSmithingItem(dtmOre_Copper, Tol);
                  Integers[ISEC] := LoadSmithingItem(dtmOre_Tin, Tol);
                  Integers[IBAR] := LoadSmithingItem(dtmBar_Bronze, Tol);
                  Integers[IBPT] := 13;
                  Booleans[BSEC] := True;
                  Extendeds[ESXP] := 6.2;
                end;
      'iron': begin
                Integers[IPRI] := LoadSmithingItem(dtmOre_Iron, Tol);
                Integers[IBAR] := LoadSmithingItem(dtmBar_Iron, Tol);
                Booleans[BSEC] := False;
                Integers[IBPT] := 27;
                Extendeds[ESXP] := 12.5;
              end;
      'steel': begin
                 Integers[IPRI] := LoadSmithingItem(dtmOre_Iron, Tol);
                 Integers[ISEC] := LoadSmithingItem(dtmOre_Coal, Tol);
                 Integers[IBAR] := LoadSmithingItem(dtmBar_Steel, Tol);
                 Integers[IBPT] := 9;
                 Booleans[BSEC] := True;
                 Extendeds[ESXP] := 17.5;
               end;
      'mith', 'mithril': begin
                           Integers[IPRI] := LoadSmithingItem(dtmOre_Mithril, Tol);
                           Integers[ISEC] := LoadSmithingItem(dtmOre_Coal, Tol);
                           Integers[IBAR] := LoadSmithingItem(dtmBar_Mithril, Tol);
                           Integers[IBPT] := 5;
                           Booleans[BSEC] := True;
                           Extendeds[ESXP] := 30;
                         end;
      'addy', 'adamant': begin
                           Integers[IPRI] := LoadSmithingItem(dtmOre_Adamantite, Tol);
                           Integers[ISEC] := LoadSmithingItem(dtmOre_Coal, Tol);
                           Integers[IBAR] := LoadSmithingItem(dtmBar_Adamant, Tol);
                           Integers[IBPT] := 3;
                           Booleans[BSEC] := True;
                           Extendeds[ESXP] := 37.5;
                         end;
      'rune': begin
                Integers[IPRI] := LoadSmithingItem(dtmOre_Runite, Tol);
                Integers[ISEC] := LoadSmithingItem(dtmOre_Coal, Tol);
                Integers[IBAR] := LoadSmithingItem(dtmBar_Rune, Tol);
                Integers[IBPT] := 3;
                Booleans[BSEC] := True;
                Extendeds[ESXP] := 50;
              end;
      'silver': begin
                  Integers[IPRI] := LoadSmithingItem(dtmOre_Silver, Tol);
                  Integers[IBAR] := LoadSmithingItem(dtmBar_Silver, Tol);
                  Integers[IBPT] := 27;
                  Booleans[BSEC] := False;
                  Extendeds[ESXP] := 13.7;
                end;
      'gold': begin
                Integers[IPRI] := LoadSmithingItem(dtmOre_Gold, Tol);
                Integers[IBAR] := LoadSmithingItem(dtmBar_Gold, Tol);
                Integers[IBPT] := 27;
                Booleans[BSEC] := False;
                Extendeds[ESXP] := 22.5;
              end;
      'blurite': begin
                   Integers[IPRI] := LoadSmithingItem(dtmOre_Blurite, Tol);
                   Integers[IBAR] := LoadSmithingItem(dtmBar_Blurite, Tol);
                   Integers[IBPT] := 27;
                   Booleans[BSEC] := False;
                   Extendeds[ESXP] := 8;
                 end;
      else
        WriteString('SetupPlayer', 'Invalid bar to make (' + Strings[0] + ').');
    end;

    // Get initial experience/levels.
    GetPlayerExpLevels;

    // Switch to friends tab.
    if not WaitForTab(Tab_Friends, True) then
    begin
      WriteString('SetupPlayer', 'Failed to switch to friends tab.');
      Exit;
    end;

    // Determine if we are on a members world. (We are not trusting info in
    // players record, we are going to make sure).
    Member := CheckMembersWorld;

    // Setup optimized click pattern for # of bars and determine optimal
    // spellbook sort order.
    TIA[TICLK] := GetClickPattern(Integers[IBPT]);
    GetSortOrder(Integers[IBPT], Member, Options, SortOrder);

    // Switch to magic tab.
    if not WaitForTab(Tab_Magic, True) then
    begin
      WriteString('SetupPlayer', 'Failed to switch to magic tab.');
      Exit;
    end;

    // Sort spellbook.
    if not SetMagicOptions(Options, SortOrder) then
    begin
      WriteString('SetupPlayer', 'Failed to set magic options.');
      Exit;
    end;

    // Move mouse away so mouseover text doesn't obscure spell icon.
    MMouse(MCX1, MCY1, MCX2, MCY2);

    // Locate superheat spell icon.
    if (TIA[TIOTH][ISHX] = 0) then
    begin
{$IFDEF DEBUG}
      WriteString('SetupPlayer', 'Locate spell icon.');
{$ENDIF}
      DTM := DTMFromString('78DA630C656260F064644006EF5E6F60E007D' +
           '220D1FF40C0180E54E382AAC69F8D898115AA060418E3806ADC50' +
           'D5E83132A3AA8904AAF1435563C784A626900835BE40355E98763' +
           '120A901002AA20BC2');
      // Because we just rearranged the spellbook the icon is moving around as
      // the spellbook sorts itself. If we find the spell icon in the same place
      // twice then assume we have it.
      for I := 0 to 4 do
      begin
        P.X := TIA[TIOTH][ISHX];
        P.Y := TIA[TIOTH][ISHY];
        if FindDTM(DTM, TIA[TIOTH][ISHX], TIA[TIOTH][ISHY], MIX1, MIY1, MIX2, MIY2) then
          if (P.X = TIA[TIOTH][ISHX]) and (P.Y = TIA[TIOTH][ISHY]) then
            Break;
        WaitRR(250, 500);
      end;
      FreeDTM(DTM);
      if (I > 4) then
      begin
        WriteString('SetupPlayer', 'Failed to locate spell icon.');
        Exit;
      end;
    end;
  end;

  // Success.
  Result := True;

end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function ActivityLoop(TimeToRunScript: Integer): Boolean;
Contributors: Bixby Sayz
Description: Main activity loop for current player.
Date Created: 2012-01-01. By Bixby Sayz. RS2 Build 695.
Last Modification: 2012-01-10. By Bixby Sayz. RS2 Build 696.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
function ActivityLoop(TimeToRunScript: Integer): Boolean;
var
  TimeToRunPlayer: Integer;  // Time counter. Time to run before break.
  T: Integer;                // Time randomization.
begin
  Result := False;
{$IFDEF DEBUG}
  WriteString('ActivityLoop', '');
{$ENDIF}

  // Generate randomized time to run before break.
  if (TimeBeforeBreak > 0) then
  begin
    T := Round(TimeBeforeBreak * 60000 * 0.1);
    TimeToRunPlayer := GetSystemTime + (TimeBeforeBreak * 60000) + RandomRange((-T), T);
  end
  else
    TimeToRunPlayer := 0;

  // Load dtms for ores/bars.
{$IFDEF DEBUG}
  WriteString('ActivityLoop', 'SetupPlayer');
{$ENDIF}
  if not SetupPlayer then
  begin
    WriteString('ActivityLoop', 'Failed to setup player');
    Exit;
  end;

  // Wrap in try..finally to ensure we free dtms.
  try

    // Perform activity loop until we hit our time limit or something goes
    // wrong.
    repeat

      // Check for randoms.
      if not CheckRandoms then
      begin
        WriteString('ActivityLoop', 'Failed random check.');
        Exit;
      end;

      // Bank finished bars and withdraw ores for next batch.
{$IFDEF DEBUG}
      WriteString('ActivityLoop', 'Do banking.');
{$ENDIF}
      if not DoBanking then
      begin
        WriteString('ActivityLoop', 'Failed to bank.');
        Exit;
      end;

      // Calculate experience gain and do short report.
      CalcExpPerHour;
      DoReport('short');

      // Is it time for a break?
      if (TimeToRunPlayer > 0) then
      begin
        Result := (GetSystemTime > TimeToRunPlayer);
        if Result then
        begin
{$IFDEF DEBUG}
          WriteString('ActivityLoop', 'Player break time reached.');
{$ENDIF}
          Break;
        end;
      end
      else
        if (TimeToRunScript > 0) then
        begin
          Result := (GetSystemTime > TimeToRunScript);
          if Result then
          begin
{$IFDEF DEBUG}
            WriteString('ActivityLoop', 'Total script time reached.');
{$ENDIF}
            Break;
          end;
        end;

      // Check for randoms.
      if not CheckRandoms then
      begin
        WriteString('ActivityLoop', 'Failed random check.');
        Exit;
      end;

      // Superheat ores.
{$IFDEF DEBUG}
      WriteString('ActivityLoop', 'Superheating ores.');
{$ENDIF}
      if not DoSuperHeat then
      begin
        WriteString('ActivityLoop', 'Failed to superheat ores.');
        Exit;
      end;

    until Result;

  finally
    // Free dtms on the way out.
{$IFDEF DEBUG}
    WriteString('ActivityLoop', 'Free player dtms.');
{$ENDIF}
    FreeDTM(Players[CurrentPlayer].Integers[IPRI]);
    if Players[CurrentPlayer].Booleans[BSEC] then
      FreeDTM(Players[CurrentPlayer].Integers[ISEC]);
    FreeDTM(Players[CurrentPlayer].Integers[IBAR]);
  end;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure MultiPlayerLoop;
Contributors: Bixby Sayz
Description: Cycle through players until all inactive.
Date Created: 2012-01-01. By Bixby Sayz. RS2 Build 695.
Last Modification: 2012-01-26. By Bixby Sayz. RS2 Build 699.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
procedure MultiPlayerLoop;
var
  TimeToRunScript: Integer;  // Time counter. Total script time.
  TimeToBreak: Integer;      // Time counter. How long to break for.
  T: Integer;                // Time randomization.
begin
{$IFDEF DEBUG}
  WriteString('MultiPlayerLoop', '');
{$ENDIF}

  // Generate randomized total script time.
  if (TimeToRun > 0) then
  begin
    T := Round(TimeToRun * 60000 * 0.1);
    TimeToRunScript := GetSystemTime + (TimeToRun * 60000) + RandomRange((-T), T);
  end
  else
    TimeToRunScript := 0;

  // Loop through players until all inactive.
  while (ActivePlayers > 0) do
  begin
    WriteString('MultiPlayerLoop', 'Current player: ' + Players[CurrentPlayer].Name);

    with Players[CurrentPlayer] do
    begin

      // Update player's status.
      Status := 'Active';

      // Login player.
{$IFDEF DEBUG}
      WriteString('MultiPlayerLoop', 'Login player');
{$ENDIF}
      if not MyLogin then
      begin
        WriteString('MultiPlayerLoop', 'Failed to login player.');
        Exit;
      end;


      // Set compass.
      if (Integers[IBNK] = Loc_SW) then
      begin
        MakeCompass(180);
        SetAngle(True);
      end
      else
        ClickCompass(True);

      // Perform activity for current player.
{$IFDEF DEBUG}
      WriteString('MultiPlayerLoop', 'Performing activity loop.');
{$ENDIF}
      if not ActivityLoop(TimeToRunScript) then
      begin
        WriteString('MultiPlayerLoop', 'Player inactive after activity loop.');
        Active := False;
      end;

      // Logout player. If only one player then only exit to lobby.
      if Active and (ActivePlayers = 1) then
      begin
        ExitToLobby;
        if not WaitFunc(@LobbyScreen, True, 25, 50, 7500, 10000) then
          ExitToLobby;
      end
      else
      begin
        Logout;
        if not WaitFunc(@LoggedIn, False, 25, 50, 7500, 10000) then
          Logout;
      end;

      // Update player's status.
      if Active then
        Status := 'Idle'
      else
        if (Status <> 'Random') then
          Status := 'Inactive';

      // Update times and experience.
      CalcExpPerHour;

      // Do report.
      DoReport('both');

      // Break between players.
      if ((TimeBeforeBreak > 0) and (BreakTime > 0)) then
        if (ActivePlayers > 0) then
        begin
          // Generate randomized break time.
          T := Round(BreakTime * 60000 * 0.1);
          TimeToBreak := (BreakTime * 60000) + RandomRange((-T), T);
          // Take a break.
{$IFDEF DEBUG}
          WriteString('MultiPlayerLoop', 'Breaking between players.');
{$ENDIF}
          TakeABreak(TimeToBreak);
        end;

      // Have we gone over our total time?
      if (TimeToRunScript > 0) then
        if (GetSystemTime > TimeToRunScript) then
        begin
          WriteString('MultiPlayerLoop', 'Total script time reached.');
          Logout;
          Exit;
        end;

      // Switch to next player.
{$IFDEF DEBUG}
      WriteString('MultiPlayerLoop', 'Switching to next player.');
{$ENDIF}
      if Active and (ActivePlayers = 1) then
        MyLogin
      else
        if (ActivePlayers > 0) then
          NextPlayer(Active);
    end;
  end;

  WriteString('MultiPlayerLoop', 'All players inactive.');
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure InitializeScript;
Contributors: Bixby Sayz
Description: Initialize script.
Date Created: 2011-12-29. By Bixby Sayz. RS2 Build 695.
Last Modification: 2012-01-04. By Bixby Sayz. RS2 Build 696.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
procedure InitializeScript;
var
  I: Integer;  // Loop counter.
begin
  SetUpOSI;
  DeclarePlayers;

  OverideRandInvTab := True;
  LoginWorldSwitcher := True;
  for I := 0 to High(Players) do
    with Players[I] do
      WorldInfo := [Member, 0, False];

  ClearDebug;
  WriteLn(Format('%s v%s (%s) by %s', [SCRIPT_NAME, SCRIPT_VERSION, SCRIPT_DATE, SCRIPT_AUTHOR]));
  WriteLn('');
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure ScriptTerminate;
Contributors: Bixby Sayz
Description: Cleanup on script end. Called automatically by SCAR on script end.
Date Created: 2011-12-29. By Bixby Sayz. RS2 Build 695.
Last Modification: 2012-01-04. By Bixby Sayz. RS2 Build 696.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
procedure ScriptTerminate;
begin
  FreeOSI;
end;

/////////////////////////////////////////////
//////////      MAIN PROGRAM      ///////////
/////////////////////////////////////////////
begin
  ClearDebug;
  WriteLn(Format('%s v%s (%s) by %s', [SCRIPT_NAME, SCRIPT_VERSION, SCRIPT_DATE, SCRIPT_AUTHOR]));
  WriteLn('');

  InitializeScript;
  MultiPlayerLoop;
end.